<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术哲思 - 技术思考在此处停留</title>
    <link>https://flike.github.io/</link>
    <description>Recent content on 技术哲思 - 技术思考在此处停留</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>技术哲思</copyright>
    <lastBuildDate>Fri, 13 Jul 2018 10:00:00 +0800</lastBuildDate>
    
        <atom:link href="https://flike.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于我</title>
      <link>https://flike.github.io/about/</link>
      <pubDate>Fri, 13 Jul 2018 10:00:00 +0800</pubDate>
      
      <guid>https://flike.github.io/about/</guid>
      
        <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;开源爱好者，kingshard数据库中间件作者。从事分布式系统架构与研发工作。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;github: &lt;a href=&#34;https://github.com/flike&#34;&gt;https://github.com/flike&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;email: flikecn@126.com&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Etcd raft lib的snapshot处理流程</title>
      <link>https://flike.github.io/post/ectd_snapshot/</link>
      <pubDate>Sun, 07 Oct 2018 19:43:53 +0800</pubDate>
      
      <guid>https://flike.github.io/post/ectd_snapshot/</guid>
      
        <description>

&lt;p&gt;snapshot的是系统状态的完整快照，其他系统接收和回放snapshot，将自身数据恢复到一个一致性状态。本文介绍一下etcd raft lib如何支持snapshot功能，主要包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;生成snapshot&lt;/li&gt;
&lt;li&gt;Leader发送snapshot&lt;/li&gt;
&lt;li&gt;Follower接收和应用snapshot&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-数据结构&#34;&gt;1.数据结构&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;type ConfState struct {
    Nodes            []uint64 `protobuf:&amp;#34;varint,1,rep,name=nodes&amp;#34; json:&amp;#34;nodes,omitempty&amp;#34;`
    XXX_unrecognized []byte   `json:&amp;#34;-&amp;#34;`
}
type SnapshotMetadata struct {
    ConfState        ConfState `protobuf:&amp;#34;bytes,1,opt,name=conf_state,json=confState&amp;#34; json:&amp;#34;conf_state&amp;#34;`
    Index            uint64    `protobuf:&amp;#34;varint,2,opt,name=index&amp;#34; json:&amp;#34;index&amp;#34;`
    Term             uint64    `protobuf:&amp;#34;varint,3,opt,name=term&amp;#34; json:&amp;#34;term&amp;#34;`
    XXX_unrecognized []byte    `json:&amp;#34;-&amp;#34;`
}
 
type Snapshot struct {
    Data             []byte           `protobuf:&amp;#34;bytes,1,opt,name=data&amp;#34; json:&amp;#34;data,omitempty&amp;#34;`
    Metadata         SnapshotMetadata `protobuf:&amp;#34;bytes,2,opt,name=metadata&amp;#34; json:&amp;#34;metadata&amp;#34;`
    XXX_unrecognized []byte           `json:&amp;#34;-&amp;#34;`
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;2-生成snapshot&#34;&gt;2.生成snapshot&lt;/h2&gt;

&lt;p&gt;etcd会在每次apply entry的时候，判断是否需要生成snapshot。判断的条件就是apply raft index 和上一个snapshot 中的index差距是否超过一定范围。如果超过，则触发snapshot服务。具体函数流程如下图所示：
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-acef615cfcac1a54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由于etcd的snapshot生成和VDL生成snapshot不一样，这里就不做详细分析。&lt;/p&gt;

&lt;h2 id=&#34;3-leader发送snapshot&#34;&gt;3.Leader发送snapshot&lt;/h2&gt;

&lt;p&gt;Leader在stepLeader函数中，会根据Follower的Next值向该Follower发送raft log。如果Leader上raft entry不存在，则会发送snapshot给follower。详细的函数调用流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-e587f8ccb0c42a20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;各个函数作用如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sendAppend:Leader根据Follower的进度发送raft log。&lt;/li&gt;
&lt;li&gt;r.raftLog.snapshot:调用存储引擎，获取最新的snapshot。&lt;/li&gt;
&lt;li&gt;pr.becomeSnapshot:将该follower状态修改为ProgressStateSnapshot，表示正在发送snapshot。&lt;/li&gt;
&lt;li&gt;send:将snapshot类型的message发送给follower。&lt;/li&gt;
&lt;li&gt;newReady:将snapshot类型的message封装在一个Ready结构中，最终raft状态机会将Ready结构体交给应用来处理。&lt;/li&gt;
&lt;li&gt;raftNode.start:在应用的外围循环中，会不断处理raft状态机传递出来的Ready结构体，对于snapshot会在r.processMessages函数中做处理。&lt;/li&gt;
&lt;li&gt;r.processMessages:将包含snapshot信息的message传递给msgSnapC。&lt;/li&gt;
&lt;li&gt;applyAll:该函数会接收msgSnapC中的消息，并调用transport发送snapshot。&lt;/li&gt;
&lt;li&gt;transport.SendSnapshot:调用transport层发送snapshot。&lt;/li&gt;
&lt;li&gt;peer.sendSnap:调用对应的peer的发送snapshot函数。&lt;/li&gt;
&lt;li&gt;snapshotSender.send:真正的snapshot发送操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-follower接收和应用snapshot&#34;&gt;4.Follower接收和应用snapshot&lt;/h2&gt;

&lt;p&gt;Follower上对snapshot的处理主要分为接收和应用snapshot两个部分，http包会创建一个goroutine来专门接收snapshot。接收完成后，会将消息传入raft状态机，然后通过消息类型来驱动状态机。具体的函数调用流程如下所示：
[图片上传失败&amp;hellip;(image-58cdb1-1522286696016)]&lt;/p&gt;

&lt;p&gt;上述主要函数作用如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-c82f2e7046f9fd87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;snapshotHandler.ServeHTTP:snapshot的handler会一直等待接收snapshot，如果收到snapshot会将其写到磁盘。&lt;/li&gt;
&lt;li&gt;snapshotter.SaveDBFrom:将收到snapshot会写到磁盘&lt;/li&gt;
&lt;li&gt;Process:将收到snapshot的消息发送到raft 状态机&lt;/li&gt;
&lt;li&gt;stepFollower:Follower收到MsgSnap消息后进入该函数。&lt;/li&gt;
&lt;li&gt;handleSnapshot:snapshot对应的消息类型是:MsgSnap，会调用handleSnapshot。&lt;/li&gt;
&lt;li&gt;r.restore:清空unstable中的entries，并将snapshot保存到unstable中。&lt;/li&gt;
&lt;li&gt;newReady:根据unstable中的snapshot设置Ready结构体。&lt;/li&gt;
&lt;li&gt;raftNode.start:将snapshot发送到applyAll对应的goroutine&lt;/li&gt;
&lt;li&gt;applyAll:调用applySnapshot&lt;/li&gt;
&lt;li&gt;applySnapshot:etcd中应用snapshot的过程。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>分布式租约机制</title>
      <link>https://flike.github.io/post/lease/</link>
      <pubDate>Sun, 07 Oct 2018 19:43:53 +0800</pubDate>
      
      <guid>https://flike.github.io/post/lease/</guid>
      
        <description>

&lt;h1 id=&#34;分布式租约机制&#34;&gt;分布式租约机制&lt;/h1&gt;

&lt;h2 id=&#34;1-什么是租约&#34;&gt;1.什么是租约&lt;/h2&gt;

&lt;p&gt;租约（lease）在分布式中一般描述如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Lease 是由授权者授予的在一段时间内的承诺。&lt;/li&gt;
&lt;li&gt;授权者一旦发出 lease，则无论接受方是否收到，也无论后续接收方处于何种状态，只要 lease 不过期，授权者一定遵守承诺，按承诺的时间、内容执行。&lt;/li&gt;
&lt;li&gt;接收方在有效期内可以使用颁发者的承诺，只要 lease 过期，接收方放弃授权，不再继续执行，要重新申请Lease。&lt;/li&gt;
&lt;li&gt;可以通过版本号、时间周期，或者到某个固定时间点认为Lease证书失效&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-1-lease机制容错能力&#34;&gt;1.1 Lease机制容错能力&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过引入有效期，Lease 机制有非常好的容错网络异常。 Lease 颁发过程只依赖于网络可以单向通信，即使接收方无法向颁发者发送消息，也不影响 lease的颁发。由于 lease 的有效期是一个确定的时间点，lease 的语义与发送 lease 的具体时间无关，所以同一个 lease 可以被颁发者不断重复向接受方发送。即使颁发者偶尔发送 lease 失败，颁发者也可以简单的通过重发的办法解决。一旦 lease 被接收方成功接受，后续 lease 机制不再依赖于网络通信，即使网络完全中断 lease 机制也不受影响。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lease 机制能较好的容错节点宕机。如果颁发者宕机，则宕机的颁发者通常无法改变之前的承诺，不会影响 lease 的正确性。在颁发者机恢复后，如果颁发者恢复出了之前的 lease 信息，颁发者可以继续遵守 lease 的承诺。如果颁发者无法恢复 lease信息，则只需等待一个最大的 lease 超时时间就可以使得所有的 lease 都失效，从而不破坏 lease 机制。例如上节中的 cache 系统的例子中，一旦服务器宕机，肯定不会修改元数据，重新恢复后，只需等待一个最大的 lease 超时时间，所有节点上的缓存信息都将被清空。对于接受方宕机的情况，颁发者不需要做更多的容错处理，只需等待 lease 过期失效，就可以收回承诺，实践中也就是收回之前赋予的权限、身份等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;lease 机制不依赖于存储。颁发者可以持久化颁发过的 lease 信息，从而在宕机恢复后可以使得在有效期的 lease 继续有效。但这对于 lease 机制只是一个优化，如之前的分析，即使颁发者没有持久化 lease 信息，也可以通过等待一个最大的 lease 时间的方式使得之前所有颁发的 lease 失效，从而保证机制继续有效。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-2-lease服务中时钟同步问题&#34;&gt;1.2 lease服务中时钟同步问题&lt;/h2&gt;

&lt;p&gt;如果颁发者的时钟比接收者的时钟慢，则当接收者认为 lease 已经过期的时候，颁发者依旧认为 lease 有效。接收者可以用在 lease 到期前申请新的 lease 的方式解决这个问题。&lt;/p&gt;

&lt;p&gt;如果颁发者的时钟比接收者的时钟快，则当颁发者认为 lease 已经过期的时候，接收者依旧认为 lease 有效，颁发者可能将 lease颁发给其他节点，造成承诺失效，影响系统的正确性。对于这种时钟不同步，实践中的通常做法是将颁发者的有效期设置得比接收者的略大，只需大过时钟误差就可以避免对 lease 的有效性的影响。&lt;/p&gt;

&lt;h2 id=&#34;2-租约在分布式系统中的应用&#34;&gt;2.租约在分布式系统中的应用&lt;/h2&gt;

&lt;p&gt;###2.1 租约机制保证缓存的一致性&lt;/p&gt;

&lt;p&gt;服务器发出Lease后，会保证在Lease的有效期内不改变数据。这样收到Lease的Client在有效期内可以放心地使用数据。在这个有效期内，Client缓存的数据和服务器上的数据是一致的。&lt;/p&gt;

&lt;p&gt;存在的问题和解决办法：&lt;/p&gt;

&lt;p&gt;1)服务器修改元数据时，需要阻塞所有的读请求，此时服务器不能发出新的Lease。以防止新发出的Lease保证的数据与服务器刚才修改的数据不一致。&lt;/p&gt;

&lt;p&gt;解决方法：读请求到来时，直接返回数据，不颁发Lease&lt;/p&gt;

&lt;p&gt;2)服务器需要等待直至所有的Client的Lease都过期后，再才颁发新“修改”后的Lease。因此，此时服务器上的数据修改了，生成了一个新的Lease版本，需要等到Client上所有的老Lease过期后，该新Lease版本才能颁布给Client。&lt;/p&gt;

&lt;p&gt;解决方法：服务器主动通知持久Lease的Client放弃当前的Lease，并请求新Lease&lt;/p&gt;

&lt;h3 id=&#34;2-2-租约机制确定节点的状态&#34;&gt;2.2 租约机制确定节点的状态&lt;/h3&gt;

&lt;p&gt;通过一个例子来讨论这个问题：在一个 primary-secondary 架构的系统中，有三个节点 A、B、C 互为副本，其中有一个节点为 primary，且同一时刻只能有一个 primary 节点。另有一个节点 Q 负责判断节点 A、B、C的状态，一旦 Q 发现 primary 异常，节点 Q 将选择另一个节点作为 primary。假设最开始时节点 A为 primary，B、C 为 secondary。节点 Q 需要判断节点 A、B、C 的状态是否正常。&lt;/p&gt;

&lt;h4 id=&#34;2-2-1-通过心跳无法很好判断节点状态&#34;&gt;2.2.1 通过心跳无法很好判断节点状态&lt;/h4&gt;

&lt;p&gt;节点 A、B、C 可以周期性的向 Q 发送心跳信息，如果节点 Q 超过一段时间收不到某个节点的心跳则认为这个节点异常。这种方法的问题是假如节点 Q 收不到节点 A 的心跳，除了节点 A 本身的异常外，也有可能是因为节点 Q 与节点 A 之间的网络中断导致的。在工程实践中，更大的可能性不是网络中断，而是节点 Q 与节点 A 之间的网络拥塞造成的所谓“闪断”，“闪断”往往很快可以恢复。另一种原因甚至是节点 Q 的机器异常，以至于处理节点 A 的心跳被延迟了，以至于节点 Q 认为节点 A 没有发送心跳。假设节点 A 本身工作正常，但 Q 与节点 A 之间的网络暂时中断，节点 A 与节点 B、C 之间的网络正常。此时节点 Q 认为节点 A 异常，重新选择节点 B 作为新的 primary，并通知节点 A、B、C 新的 primary 是节点 B。由于节点 Q 的通知消息到达节点 A、B、C 的顺序无法确定，假如先到达 B，则在这一时刻，系统中同时存在两个工作中的 primary，一个是 A、另一个是 B。假如此时 A、B 都接收外部请求并与 C 同步数据，会产生严重的数据错误。上述即所谓“双主”问题。&lt;/p&gt;

&lt;h4 id=&#34;2-2-2-双主问题的解决&#34;&gt;2.2.2 双主问题的解决&lt;/h4&gt;

&lt;p&gt;由中心节点向其他节点发送 lease，若某个节点持有有效的 lease，则认为该节点正常可以提供服务。如节点 A、 B、 C 依然周期性的发送 heart beat 报告自身状态，节点 Q 收到 heart beat后发送一个 lease，表示节点 Q 确认了节点 A、B、C 的状态，并允许节点在 lease 有效期内正常工作。节点 Q 可以给 primary 节点一个特殊的 lease，表示节点可以作为 primary 工作。一旦节点 Q 希望切换新的 primary，则只需等前一个 primary 的 lease 过期，则就可以安全的颁发新的 lease 给新的primary 节点，而不会出现“双主”问题。&lt;/p&gt;

&lt;h2 id=&#34;3-总结&#34;&gt;3.总结&lt;/h2&gt;

&lt;p&gt;本文将Lease机制的本质及在分布式系统中的主要应用梳理出来了，希望对读者在分布式系统中使用lease机制有帮助。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Braft的日志存储引擎实现分析</title>
      <link>https://flike.github.io/post/braft_storage/</link>
      <pubDate>Sun, 07 Oct 2018 18:37:51 +0800</pubDate>
      
      <guid>https://flike.github.io/post/braft_storage/</guid>
      
        <description>

&lt;h2 id=&#34;1-架构设计&#34;&gt;1.架构设计&lt;/h2&gt;

&lt;h3 id=&#34;1-1-函数接口说明&#34;&gt;1.1 函数接口说明&lt;/h3&gt;

&lt;p&gt;日志存储引擎是用于存储raft lib产生的日志。提供的接口如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;class LogStorage {
public:
    virtual ~LogStorage() {}

    // init logstorage, check consistency and integrity
    virtual int init(ConfigurationManager* configuration_manager) = 0;

    // first log index in log
    virtual int64_t first_log_index() = 0;

    // last log index in log
    virtual int64_t last_log_index() = 0;

    // get logentry by index
    virtual LogEntry* get_entry(const int64_t index) = 0;

    // get logentry&amp;#39;s term by index
    virtual int64_t get_term(const int64_t index) = 0;

    // append entries to log
    virtual int append_entry(const LogEntry* entry) = 0;

    // append entries to log, return append success number
    virtual int append_entries(const std::vector&amp;lt;LogEntry*&amp;gt;&amp;amp; entries) = 0;

    // delete logs from storage&amp;#39;s head, [first_log_index, first_index_kept) will be discarded
    virtual int truncate_prefix(const int64_t first_index_kept) = 0;

    // delete uncommitted logs from storage&amp;#39;s tail, (last_index_kept, last_log_index] will be discarded
    virtual int truncate_suffix(const int64_t last_index_kept) = 0;

    // Drop all the existing logs and reset next log index to |next_log_index|.
    // This function is called after installing snapshot from leader
    virtual int reset(const int64_t next_log_index) = 0;

    // Create an instance of this kind of LogStorage with the parameters encoded 
    // in |uri|
    // Return the address referenced to the instance on success, NULL otherwise.
    virtual LogStorage* new_instance(const std::string&amp;amp; uri) const = 0;

    static LogStorage* create(const std::string&amp;amp; uri);
};&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;LogStorage只是一个抽象类，只定义了函数接口。具体的日志操作由SegmentLogStorage实现。&lt;/p&gt;

&lt;h3 id=&#34;1-2-存储引擎的数据组织&#34;&gt;1.2 存储引擎的数据组织&lt;/h3&gt;

&lt;p&gt;SegmentLogStorage实现了LogStorage的全部接口。其数据组织格式如下：
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-26d6c05e299f2316.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;segment名字为first_raft_index-last_raft_index，表示该segment的raft index范围。&lt;/li&gt;
&lt;li&gt;只有最后一个segment可读写，其文件名为log_inprogress_first_raft_index，其他segment只读。&lt;/li&gt;
&lt;li&gt;segment文件对应的index entry，Segment文件初始化时构造出来，存储在内存中。不会持久化到磁盘。因此追加一次Log Entry只会引起一次磁盘操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-核心流程实现&#34;&gt;2.核心流程实现&lt;/h2&gt;

&lt;h3 id=&#34;2-1-存储引擎的接口函数&#34;&gt;2.1 存储引擎的接口函数&lt;/h3&gt;

&lt;h3 id=&#34;2-2-存储引擎的初始化&#34;&gt;2.2 存储引擎的初始化&lt;/h3&gt;

&lt;p&gt;存储引擎的初始化操作主要检查文件信息，将segment的索引信息加载到内存，为读写操作做准备。
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-8e690f46ac9d5454.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;函数主要功能如下所述：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;init函数是SegmentLogStorage初始化的入口函数，调用load_meta函数，list_segment函数和load_segment函数。&lt;/li&gt;
&lt;li&gt;load_meta函数：从log_meta文件中读取从SegmentLogStorage的第一个raft index值。&lt;/li&gt;
&lt;li&gt;list_segment函数：建立起segment的范围信息，并将范围异常的segment文件删除。范围信息存储在一个map表中，map的key是first_raft_index,value是segment对象。&lt;/li&gt;
&lt;li&gt;load_segments函数：构建出每个segment对应的索引项，通过解析segement内容完成。索引项存储在一个vector中。至此，就可以根据范围信息来定位到某个raft_index对应的文件偏移。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-3-写数据流程&#34;&gt;2.3 写数据流程&lt;/h3&gt;

&lt;p&gt;写数据到存储引擎，会涉及到两个函数:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt; // append entry to log
    int append_entry(const LogEntry* entry);
 // append entries to log, return success append number
   int append_entries(const std::vector&amp;lt;LogEntry*&amp;gt;&amp;amp; entries);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;append_entry表示追加单条Log Entry到日志存储引擎，append_entries用于同时追加多条Log Entry到日志存储引擎。两个函数主要流程相差不大，我们以append_entries为例，分析一下写入Log Entry的主要流程。函数流程图如下所示：
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-84bb92948772875b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查日志连续性：主要检查last_raft_index 是否和追加的Log Entry保持连续。&lt;/li&gt;
&lt;li&gt;获取Last_Segment：检查last_segment是否超过Max_Segment_Size，如果超过则进行rolling操作（保存最后一个segment，并生成一个新的segment）。如果文件大小未超过Max_Segment_Size，则直接返回。&lt;/li&gt;
&lt;li&gt;循环追加日志：追加Log Entry到文件末尾。&lt;/li&gt;
&lt;li&gt;Last_Segment强制刷盘：调用fsync函数强制刷盘。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-4-读数据流程&#34;&gt;2.4 读数据流程&lt;/h3&gt;

&lt;p&gt;根据raft_index读取对应的raft Log，根据我们前面提到的索引信息，braft很容易实现，流程图如下所示：
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-ff64112d601ce14c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;get_entry是入口函数，get_segment函数主要是通过raft_index来定位到segment，通过之前建立的Map范围信息很容易定位到。然后根据每个segment的Vector索引数组，定位到raft_index对应的文件偏移信息。然后读取文件。&lt;/p&gt;

&lt;h3 id=&#34;2-5-删除数据流程&#34;&gt;2.5 删除数据流程&lt;/h3&gt;

&lt;p&gt;删除数据分为两类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从前往后删除，对应的函数是：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;SegmentLogStorage::truncate_prefix(const int64_t first_index_kept)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;truncate_prefix函数先将first_index_kept保存到Log_meta文件中，这样保证了即使后续的文件删除操作失败时，也可以知道整个日志的起始raft_index是多少。保存完first_index_kept之后，将first_index_kept之前的segment文件全部删除。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从后往前删除，对应的函数是：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;int SegmentLogStorage::truncate_suffix(const int64_t last_index_kept) &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;主要用于raft lib中删除未达成一致的Log Entry。根据last_index_kept找到对应的文件偏移，然后截断文件。如果跨文件，还需要删除最后一个segment文件，然后再截断之前一个segment的内容。&lt;/p&gt;

&lt;p&gt;##3.测试
在test/test_log.cpp文件中，包含SegmentLogStorage类中主要的接口函数的单元测试，对理解SegmentLogStorage有比较大的帮助。&lt;/p&gt;

&lt;h2 id=&#34;4-总结&#34;&gt;4.总结&lt;/h2&gt;

&lt;p&gt;Braft的日志存储引擎，主要用于存储raft log。当执行完一次snapshot操作后，就可以进行Log Compaction。将snapshot之前的raft log全部删除。这使得Braft可以将Log的索引信息全部存储在内存中，因为存储引擎中的Raft Log Entry不会太大。这样追加或读取Raft Log只需要一次磁盘操作，性能方面有保证。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>从零开始开发一个单机存储引擎</title>
      <link>https://flike.github.io/post/storage_arch/</link>
      <pubDate>Sun, 07 Oct 2018 14:43:53 +0800</pubDate>
      
      <guid>https://flike.github.io/post/storage_arch/</guid>
      
        <description>

&lt;h2 id=&#34;1-vdl-logstore概述&#34;&gt;1 VDL Logstore概述&lt;/h2&gt;

&lt;p&gt;如何设计存储引擎，使得读写接口的性能足够高，如何保证在机器宕机时，存储引擎能够将已存储的数据恢复到一个一致性状态。如何测试存储引擎的正确性？本文将着重介绍一下VDL系统的日志存储引擎&amp;ndash;Logstore的架构设计与核心流程实现，及为了保证Logstore的正确性，我们做了哪些工作；为了进一步提高Logstore的读写性能，我们又做了哪些工作。希望通过这篇文章，给大家介绍一下设计和开发一个存储引擎的『前世今生』。&lt;/p&gt;

&lt;h3 id=&#34;1-1-logstore提供的功能&#34;&gt;1.1 Logstore提供的功能&lt;/h3&gt;

&lt;p&gt;VDL中有两种日志形态，一种是raft日志（以下称为raft log），由raft算法产生和使用，另一种是用户形态的Log（以下称为user log），由用户产生和使用。Logstore作为VDL日志存储引擎，同时存储着VDL的raft log 和user log。Logstore在设计中，将两种Log形态组合成一个Log Entry。只是通过不同的头部信息来区分。Logstore需要同时提供两种不同形态的Log操作接口，主要有以下几类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;读取，根据索引信息，读取对应的Log。&lt;/li&gt;
&lt;li&gt;写入，将用户产生的Log，封装成相应的user Log和Raft Log写入到Logstore中。&lt;/li&gt;
&lt;li&gt;删除，删除用户不再使用的Log，以文件为粒度，从最开始位置往后删除。&lt;/li&gt;
&lt;li&gt;转换，由Raft Log获取对应的user Log。&lt;/li&gt;
&lt;li&gt;截断，截断一部分Log，主要是为了支持raft lib中删除未达成一致的Log的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-logstore的架构设计&#34;&gt;2.Logstore的架构设计&lt;/h2&gt;

&lt;h3 id=&#34;2-1系统架构&#34;&gt;2.1系统架构&lt;/h3&gt;

&lt;p&gt;Logstore由数据文件和索引文件组成，同时Logstore还会在内存中缓存最新的一段Log Entry，用于Raft lib能够快速地从内存中读取到最近Raft log，同时用户也能够快速读取到最新存储到Logstore中的user log。Logstore的组成如下图所示：
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-f32b0b7fbe63ef64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;segment: 用于存储log的文件，大小固定（默认是512MB）。Segment文件从前到后代表着log的顺序，Logstore通过追加的方式不断将Log Entry写入到segment中。Logstore只追加Log Entry到最后的Segment文件中，对于整个Logstore只有最后一个segment可读可写，其他Segment文件只读。由于Segment文件大小固定，我们采用mmap函数方式对segment文件进行读写。&lt;/li&gt;
&lt;li&gt;index: 用于存储对应的segment中的log entry的元信息，例如：log entry在segment文件中的偏移，raft log index等。每个索引项大小固定。用于加速查找raft log和user log。&lt;/li&gt;
&lt;li&gt;MemCache: 缓存最后一段log entry数据，保证VDL能够从内存中读取最新的一段log entry数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;segment由一条一条的raft log entry组成，raft log的data部分存放的是user log。每个segment文件对应一个index文件，index file由index entry组成，index 文件中的索引项纪录了对应raft log的位置和大小等信息。示意图如下所示：
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-3c08dbe4cdc058a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-logstore的核心流程实现&#34;&gt;3. Logstore的核心流程实现&lt;/h2&gt;

&lt;h3 id=&#34;3-1-读数据流程&#34;&gt;3.1 读数据流程&lt;/h3&gt;

&lt;p&gt;Logstore读数据分为两种情况：&lt;/p&gt;

&lt;p&gt;Read in MemCache,MemCache的元数据记录了缓存的Log范围信息，当读取范围刚好落在MemCache内时，则Logstore直接从MemCache中读取Log并返回。
Read in Segment,当上层读取的Log范围未完全落在MemCache中时，则会从segment文件中读取。Logstore记录了每个segment的Log范围元数据信息，先通过segment范围元数据信息，定位到读取的开始segment，然后在通过索引来定位具体的文件偏移。例如，读取raft index 为10010-10019这段范围的raft log,segment范围如下图所示：
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-63d10fc1b202720a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;根据segment的Log范围元数据信息，我们可以知道此次读取范围开始位置和结束位置都在segment_2中，由于Raft log entry的长度是不固定的，如何定位读取开始位置和结束位置的文件偏移呢？这时候就需要用到索引项，在Logstore中每个Log entry对应的索引项大小是固定的，索引项纪录了该raft log entry在segment文件内的文件偏移。segment_2对应的index文件第一个索引项纪录的是raft index为10001的raft log entry索引项，所以需要在index文件中超找raft log index范围是：10010-10019，就非常简单了。直接读取index 文件的第10到第19范围的索引项，然后根据索引项内的文件偏移到segment上读取raft log。大概的流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-9ba37bc712105e45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-2-写数据流程&#34;&gt;3.2 写数据流程&lt;/h3&gt;

&lt;p&gt;raft算法要求写入的raft log必须强制落盘后，才能返回成功。通过将log entry批量异步写入segment文件，并调用sync_file_range函数强制刷盘。为了提升写入segment性能，segment文件创建时就预分配了512MB的磁盘空间，这种预分配文件空间的方式有助于提升写性能。将索引信息写入index文件是异步写完后就返回。同步写segment，异步写index的方式降低了raft log写耗时，但又不影响raft算法的正确性。因为raft算法是以segment中的数据作为参考标准的。&lt;/p&gt;

&lt;p&gt;Logstore写入流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-ee40bae97ee50651.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-3-数据恢复流程&#34;&gt;3.3 数据恢复流程&lt;/h3&gt;

&lt;p&gt;Logstore必须要考虑到在VDL系统异常退出时，存储的数据有可能出现不一致。例如在Logstore写数据过程中，机器突然宕机。这时候就有可能只写入了部分数据，在设计Logstore时就必须考虑到如何支持数据恢复操作，保证写入Logstore的数据的一致性。&lt;/p&gt;

&lt;p&gt;在Logstore中，只有最后一个segment文件可能出现数据不一致的可能。因为Logstore在写满一个segment文件后，会创建一个新的segment文件。在创建新的segment文件之前，Logstore通过sync系统调用让最后的segment对应的index文件内容强制刷盘，并且最后一个segment文件写入本身就是同步写。通过这种机制保证了只有最后一个segment写入的数据存在部分写的可能。而在这之前的segment文件和index文件内容都是完整的。&lt;/p&gt;

&lt;p&gt;有了上面的保证，数据恢复我们只需要考虑最后一个segment及其index文件中的数据是否完整。Logstore通过一个标识文件来标识系统是否正常退出，如果文件存在且里面的标记为正常退出，Logstore就走正常启动流程，否则，转入数据恢复流程，Logstore数据恢复流程，主要操作如下图所示：
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-1cd3af3df6dd9424.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-logstore的测试&#34;&gt;4.Logstore的测试&lt;/h2&gt;

&lt;p&gt;为保证Logstore的正确性，我们对Logstore对外提供的接口函数及内部调用的核心函数都做了单元测试，通过gitlab+jenkins持续集成的方式，保证每次提交都会触发脚本将所有的单元测试重新运行一次，如果新增代码或改动代码，导致单元测试失败，我们可以立刻发现。通过这种持续集成的方式，我们可以保证每次代码提交的质量。&lt;/p&gt;

&lt;p&gt;仅仅有单元测试还是不够的，因为我们无法预测Logstore某个接口函数异常，对整个VDL系统造成什么影响。所以，我们还对Logstore进行了异常测试，通过一个自研工具FIU，对Logstore中特定的函数注入各种异常条件，测试Logstore的在异常情况下，对系统的影响。我们在Logstore相关代码中插入固定的异常代码，然后通过FIU来触发相应的异常点。这样就可以让Logstore走入指定的异常逻辑代码。异常注入测试主要分为两类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;增加读或写延迟，Logstore向上层提供读写raft log和user log等操作。例如，读取raft log增加3s的延迟、写入user log增加1s-3s的随机延迟。我们测试在这类异常场景下，对上层VDL会造成什么影响，结果是否跟我们的预期一致。&lt;/li&gt;
&lt;li&gt;部分写问题，机器突然宕机，有可能导致Logstore部分写操作。也就是segment有可能只写入了部分数据，或者index文件只写入了部分数据。同样，我们也是在写入segment文件逻辑和index文件逻辑中增加异常点，利用FIU触发指定的异常逻辑。这样就可以测试到在Logstore出现部分写时，Logstore的数据恢复流程是否能够正常工作，是否符合预期。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了这类异常测试，我们可以提前去模拟线上有可能出现的异常场景，并修复可能存在的未知缺陷。保证VDL上线后更加稳定、可靠。并且添加异常各类异常测试用例是一个持续的过程，伴随着VDL系统开发和演进的全过程。&lt;/p&gt;

&lt;h2 id=&#34;5-logstore的性能优化&#34;&gt;5.Logstore的性能优化&lt;/h2&gt;

&lt;p&gt;为保证Logstore具有高性能的读写，在设计阶段就考虑到了。比如通过文件空间预分配来提升写性能，通过mmap方式读日志数据，提升读性能。在代码开发完成后，结合go pprof和火焰图来定位Logstore的性能开销较大的系统调用或代码段，并做相应优化。性能优化方面的工作，比较有意义的几点，可以分享一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;批量写数据，不管是写segment还是写index文件，都是将数据先组合在一个内存空间中，然后批量写入到磁盘。减少IO调用带来的开销。&lt;/li&gt;
&lt;li&gt;index文件异步刷盘，在前面的设计中，我们谈到在segment rolling操作中，需要将index文件同步刷盘后，再创建新的segment文件。通过持续观察发现，每次index文件刷盘都要消耗4ms-8ms的时间。写入操作如果需要segment rolling时，这次的写入延迟额外会增加4ms-8ms。Logstore的写入就会出现抖动。经过分析，我们可以发现index文件同步刷盘所做的操作就是将index文件对应的内存脏页更新到磁盘。如果我们能够减少segment rolling操作时index文件对应的内存脏页数量。就可以缩短index刷盘的耗时。我们采用的方式是每次写index文件时，再调用sync_file_range操作异步将index文件数据刷盘，这样就可以分摊最后一次刷盘的压力。经过优化后的index文件刷盘操作耗时缩短到200us-300us。使得整个Lostore的写入耗时更加平滑。
在核心函数调用中Logstore记录相关metric信息，在Logstore上线后，通过日志收集系统，收集metric信息到influxdb，然后通过grafana展示出来。有了grafana的直观展示，我们可以监控到耗时比较长的系统调用，并做针对性地优化。目前关键的读取和写入操作都达到了预期的性能目标。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-总结&#34;&gt;6.总结&lt;/h2&gt;

&lt;p&gt;本文介绍了Logstore在设计、开发、测试和性能优化等方面，我们所做的工作。希望能够给读者在设计和开发分布式存储系统时，提供一定的参考思路。在后续演进中，我们希望结合业务场景，对数据做冷热分离，进一步降低生产系统的成本。到时候有新的心得体会，我们继续给大家分享。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Raft的PreVote实现机制</title>
      <link>https://flike.github.io/post/raft_prevote/</link>
      <pubDate>Sun, 07 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://flike.github.io/post/raft_prevote/</guid>
      
        <description>

&lt;h2 id=&#34;1-背景&#34;&gt;&lt;strong&gt;1. 背景&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在Basic Raft算法中，当一个Follower与其他节点网络隔离，如下图所示：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/66307-64cbd82b30ffb525.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Follower_2在electionTimeout没收到心跳之后,会发起选举，并转为Candidate。每次发起选举时，会把Term加一。由于网络隔离，它既不会被选成Leader，也不会收到Leader的消息，而是会一直不断地发起选举。Term会不断增大。&lt;/p&gt;

&lt;p&gt;一段时间之后，这个节点的Term会非常大。在网络恢复之后，这个节点会把它的Term传播到集群的其他节点，导致其他节点更新自己的term，变为Follower。然后触发重新选主，但这个旧的Follower_2节点由于其日志不是最新，并不会成为Leader。整个集群被这个网络隔离过的旧节点扰乱，显然需要避免的。&lt;/p&gt;

&lt;h2 id=&#34;2-provote算法&#34;&gt;&lt;strong&gt;2. Provote算法&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Raft作者博士论文《CONSENSUS: BRIDGING THEORY AND PRACTICE》的第9.6节 &amp;ldquo;Preventing disruptions when a server rejoins the cluster&amp;rdquo;提到了PreVote算法的大概实现思路。&lt;/p&gt;

&lt;p&gt;在PreVote算法中，Candidate首先要确认自己能赢得集群中大多数节点的投票，这样才会把自己的term增加，然后发起真正的投票。其他投票节点同意发起选举的条件是（同时满足下面两个条件）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有收到有效领导的心跳，至少有一次选举超时。&lt;/li&gt;
&lt;li&gt;Candidate的日志足够新（Term更大，或者Term相同raft index更大）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PreVote算法解决了网络分区节点在重新加入时，会中断集群的问题。在PreVote算法中，网络分区节点由于无法获得大部分节点的许可，因此无法增加其Term。然后当它重新加入集群时，它仍然无法递增其Term，因为其他服务器将一直收到来自Leader节点的定期心跳信息。一旦该服务器从领导者接收到心跳，它将返回到Follower状态，Term和Leader一致。&lt;/p&gt;

&lt;h2 id=&#34;3-etcd的provote实现流程&#34;&gt;&lt;strong&gt;3. Etcd的Provote实现流程&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Etcd针对发起PreVote的节点增加了一个角色状态：StatePreCandidate。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;const (
    StateFollower StateType = iota
    StateCandidate
    StateLeader
    StatePreCandidate
    numStates
)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;3-1-节点发起prevote流程&#34;&gt;&lt;strong&gt;3.1 节点发起PreVote流程&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;1.首先节点超时，会进入Step函数，然后触发选举流程，如果配置了prevote，则会进入预选举流程，代码片段如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;case pb.MsgHup:
        if r.state != StateLeader {
            ents, err := r.raftLog.slice(r.raftLog.applied+1, r.raftLog.committed+1, noLimit)
            if err != nil {
                r.logger.Panicf(&amp;#34;unexpected error getting unapplied entries (%v)&amp;#34;, err)
            }
            if n := numOfPendingConf(ents); n != 0 &amp;amp;&amp;amp; r.raftLog.committed &amp;gt; r.raftLog.applied {
                r.logger.Warningf(&amp;#34;%x cannot campaign at term %d since there are still %d pending configuration changes to apply&amp;#34;, r.id, r.Term, n)
                return nil
            }

            r.logger.Infof(&amp;#34;%x is starting a new election at term %d&amp;#34;, r.id, r.Term)
            if r.preVote {
                r.campaign(campaignPreElection)
            } else {
                r.campaign(campaignElection)
            }
        } else {
            r.logger.Debugf(&amp;#34;%x ignoring MsgHup because already leader&amp;#34;, r.id)
        }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.节点调用r.campaign(campaignPreElection)，发送投票请求。函数流程如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func (r *raft) campaign(t CampaignType) {
    var term uint64
    var voteMsg pb.MessageType
    if t == campaignPreElection {
        r.becomePreCandidate()
        voteMsg = pb.MsgPreVote
        // PreVote RPCs are sent for the next term before we&amp;#39;ve incremented r.Term.
        //关键点：这里raft的term不会增加，先以r.Term + 1询问其他节点，而不增加自己的真实term
        term = r.Term + 1
    } else {
        r.becomeCandidate()
        voteMsg = pb.MsgVote
        term = r.Term
    }
    //检查投票是否过半，第一次进入该函数不会执行这段逻辑。
    //流程3，会统计投票结果
    if r.quorum() == r.poll(r.id, voteRespMsgType(voteMsg), true) {
        // We won the election after voting for ourselves (which must mean that
        // this is a single-node cluster). Advance to the next state.
        if t == campaignPreElection {
            r.campaign(campaignElection)
        } else {
            r.becomeLeader()
        }
        return
    }
    //向其他节点发送投票请求
    for id := range r.prs {
        if id == r.id {
            continue
        }
        r.logger.Infof(&amp;#34;%x [logterm: %d, index: %d] sent %s request to %x at term %d&amp;#34;,
            r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), voteMsg, id, r.Term)

        var ctx []byte
        if t == campaignTransfer {
            ctx = []byte(t)
        }
        r.send(pb.Message{Term: term, To: id, Type: voteMsg, Index: r.raftLog.lastIndex(), LogTerm: r.raftLog.lastTerm(), Context: ctx})
    }
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3.当发起prevote节点收到响应消息以后，会进入stepCandidate函数，stepCandidate函数是PreCandidate状态和Candidate状态共用的。当收到其他节点对投票的响应时，重新计算自己的票数。如果达到大多数，PreCandidate会变为Candidate状态，发起真正的选举。代码片段如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func stepCandidate(r *raft, m pb.Message) error {
    // Only handle vote responses corresponding to our candidacy (while in
    // StateCandidate, we may get stale MsgPreVoteResp messages in this term from
    // our pre-candidate state).
    var myVoteRespType pb.MessageType
    if r.state == StatePreCandidate {
        myVoteRespType = pb.MsgPreVoteResp
    } else {
        myVoteRespType = pb.MsgVoteResp
    }
    switch m.Type {
    ...
    case myVoteRespType:
      //统计赞成票和反对票
        gr := r.poll(m.From, m.Type, !m.Reject)
        r.logger.Infof(&amp;#34;%x [quorum:%d] has received %d %s votes and %d vote rejections&amp;#34;, r.id, r.quorum(), gr, m.Type, len(r.votes)-gr)
        switch r.quorum() {
        case gr:
          //当赞成票过半后，PreVote直接转入第二个阶段：正式选举
            if r.state == StatePreCandidate {
                r.campaign(campaignElection)
            } else {
              //如果已经是StateCandidate,则直接变为Leader，选举结束。
                r.becomeLeader()
                r.bcastAppend()
            }
        case len(r.votes) - gr:
            // pb.MsgPreVoteResp contains future term of pre-candidate
            // m.Term &amp;gt; r.Term; reuse r.Term
            //如果反对票已过半，这直接变为Follower，并且不增加term
            r.becomeFollower(r.Term, None)
        }
    ...
    }
    return nil
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;3-2-节点响应prevote流程&#34;&gt;&lt;strong&gt;3.2 节点响应PreVote流程&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;节点收到Prevote请求，都会进入Step函数，然后做相应的响应处理：
1.如果当前节点未选举超时，并且存在Leader，则不响应投票请求
2.如果满足投票要求，并且日志最新，则投赞成票，否则投反对票。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func (r *raft) Step(m pb.Message) error {
    // Handle the message term, which may result in our stepping down to a follower.
    switch {
    ...
    //#1
    case m.Term &amp;gt; r.Term:
        if m.Type == pb.MsgVote || m.Type == pb.MsgPreVote {
            force := bytes.Equal(m.Context, []byte(campaignTransfer))
            inLease := r.checkQuorum &amp;amp;&amp;amp; r.lead != None &amp;amp;&amp;amp; r.electionElapsed &amp;lt; r.electionTimeout
            if !force &amp;amp;&amp;amp; inLease {
                // If a server receives a RequestVote request within the minimum election timeout
                // of hearing from a current leader, it does not update its term or grant its vote
                r.logger.Infof(&amp;#34;%x [logterm: %d, index: %d, vote: %x] ignored %s from %x [logterm: %d, index: %d] at term %d: lease is not expired (remaining ticks: %d)&amp;#34;,
                    r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term, r.electionTimeout-r.electionElapsed)
                return nil
            }
        }
    ...
    case pb.MsgVote, pb.MsgPreVote:
    ...
    //#2
        // We can vote if this is a repeat of a vote we&amp;#39;ve already cast...
        canVote := r.Vote == m.From ||
            // ...we haven&amp;#39;t voted and we don&amp;#39;t think there&amp;#39;s a leader yet in this term...
            (r.Vote == None &amp;amp;&amp;amp; r.lead == None) ||
            // ...or this is a PreVote for a future term...
            (m.Type == pb.MsgPreVote &amp;amp;&amp;amp; m.Term &amp;gt; r.Term)
        // ...and we believe the candidate is up to date.
        if canVote &amp;amp;&amp;amp; r.raftLog.isUpToDate(m.Index, m.LogTerm) {
            ...
            r.send(pb.Message{To: m.From, Term: m.Term, Type: voteRespMsgType(m.Type)})
            if m.Type == pb.MsgVote {
                // Only record real votes.
                r.electionElapsed = 0
                r.Vote = m.From
            } else {
            ...
            r.send(pb.Message{To: m.From, Term: r.Term, Type: voteRespMsgType(m.Type), Reject: true})
        }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;4-总结&#34;&gt;&lt;strong&gt;4. 总结&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Prevote是一个典型的2PC协议，第一阶段先征求其他节点是否同意选举，如果同意选举则发起真正的选举操作，否则降为Follower角色。这样就避免了网络分区节点重新加入集群，触发不必要的选举操作。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>