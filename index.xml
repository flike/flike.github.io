<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术哲思 - 技术思考在此处停留</title>
    <link>https://flike.github.io/</link>
    <description>Recent content on 技术哲思 - 技术思考在此处停留</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>技术哲思</copyright>
    <lastBuildDate>Fri, 13 Jul 2018 10:00:00 +0800</lastBuildDate>
    
        <atom:link href="https://flike.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于我</title>
      <link>https://flike.github.io/about/</link>
      <pubDate>Fri, 13 Jul 2018 10:00:00 +0800</pubDate>
      
      <guid>https://flike.github.io/about/</guid>
      
        <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;开源爱好者，kingshard数据库中间件作者。从事分布式系统架构与研发工作。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;github: &lt;a href=&#34;https://github.com/flike&#34;&gt;https://github.com/flike&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;email: flikecn@126.com&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>从零开始开发一个单机存储引擎</title>
      <link>https://flike.github.io/post/2/</link>
      <pubDate>Sun, 07 Oct 2018 14:43:53 +0800</pubDate>
      
      <guid>https://flike.github.io/post/2/</guid>
      
        <description>

&lt;h2 id=&#34;1-vdl-logstore概述&#34;&gt;1 VDL Logstore概述&lt;/h2&gt;

&lt;p&gt;如何设计存储引擎，使得读写接口的性能足够高，如何保证在机器宕机时，存储引擎能够将已存储的数据恢复到一个一致性状态。如何测试存储引擎的正确性？本文将着重介绍一下VDL系统的日志存储引擎&amp;ndash;Logstore的架构设计与核心流程实现，及为了保证Logstore的正确性，我们做了哪些工作；为了进一步提高Logstore的读写性能，我们又做了哪些工作。希望通过这篇文章，给大家介绍一下设计和开发一个存储引擎的『前世今生』。&lt;/p&gt;

&lt;h3 id=&#34;1-1-logstore提供的功能&#34;&gt;1.1 Logstore提供的功能&lt;/h3&gt;

&lt;p&gt;VDL中有两种日志形态，一种是raft日志（以下称为raft log），由raft算法产生和使用，另一种是用户形态的Log（以下称为user log），由用户产生和使用。Logstore作为VDL日志存储引擎，同时存储着VDL的raft log 和user log。Logstore在设计中，将两种Log形态组合成一个Log Entry。只是通过不同的头部信息来区分。Logstore需要同时提供两种不同形态的Log操作接口，主要有以下几类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;读取，根据索引信息，读取对应的Log。&lt;/li&gt;
&lt;li&gt;写入，将用户产生的Log，封装成相应的user Log和Raft Log写入到Logstore中。&lt;/li&gt;
&lt;li&gt;删除，删除用户不再使用的Log，以文件为粒度，从最开始位置往后删除。&lt;/li&gt;
&lt;li&gt;转换，由Raft Log获取对应的user Log。&lt;/li&gt;
&lt;li&gt;截断，截断一部分Log，主要是为了支持raft lib中删除未达成一致的Log的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-logstore的架构设计&#34;&gt;2.Logstore的架构设计&lt;/h2&gt;

&lt;h3 id=&#34;2-1系统架构&#34;&gt;2.1系统架构&lt;/h3&gt;

&lt;p&gt;Logstore由数据文件和索引文件组成，同时Logstore还会在内存中缓存最新的一段Log Entry，用于Raft lib能够快速地从内存中读取到最近Raft log，同时用户也能够快速读取到最新存储到Logstore中的user log。Logstore的组成如下图所示：
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-f32b0b7fbe63ef64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;segment: 用于存储log的文件，大小固定（默认是512MB）。Segment文件从前到后代表着log的顺序，Logstore通过追加的方式不断将Log Entry写入到segment中。Logstore只追加Log Entry到最后的Segment文件中，对于整个Logstore只有最后一个segment可读可写，其他Segment文件只读。由于Segment文件大小固定，我们采用mmap函数方式对segment文件进行读写。&lt;/li&gt;
&lt;li&gt;index: 用于存储对应的segment中的log entry的元信息，例如：log entry在segment文件中的偏移，raft log index等。每个索引项大小固定。用于加速查找raft log和user log。&lt;/li&gt;
&lt;li&gt;MemCache: 缓存最后一段log entry数据，保证VDL能够从内存中读取最新的一段log entry数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;segment由一条一条的raft log entry组成，raft log的data部分存放的是user log。每个segment文件对应一个index文件，index file由index entry组成，index 文件中的索引项纪录了对应raft log的位置和大小等信息。示意图如下所示：
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-3c08dbe4cdc058a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-logstore的核心流程实现&#34;&gt;3. Logstore的核心流程实现&lt;/h2&gt;

&lt;h3 id=&#34;3-1-读数据流程&#34;&gt;3.1 读数据流程&lt;/h3&gt;

&lt;p&gt;Logstore读数据分为两种情况：&lt;/p&gt;

&lt;p&gt;Read in MemCache,MemCache的元数据记录了缓存的Log范围信息，当读取范围刚好落在MemCache内时，则Logstore直接从MemCache中读取Log并返回。
Read in Segment,当上层读取的Log范围未完全落在MemCache中时，则会从segment文件中读取。Logstore记录了每个segment的Log范围元数据信息，先通过segment范围元数据信息，定位到读取的开始segment，然后在通过索引来定位具体的文件偏移。例如，读取raft index 为10010-10019这段范围的raft log,segment范围如下图所示：
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-63d10fc1b202720a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;根据segment的Log范围元数据信息，我们可以知道此次读取范围开始位置和结束位置都在segment_2中，由于Raft log entry的长度是不固定的，如何定位读取开始位置和结束位置的文件偏移呢？这时候就需要用到索引项，在Logstore中每个Log entry对应的索引项大小是固定的，索引项纪录了该raft log entry在segment文件内的文件偏移。segment_2对应的index文件第一个索引项纪录的是raft index为10001的raft log entry索引项，所以需要在index文件中超找raft log index范围是：10010-10019，就非常简单了。直接读取index 文件的第10到第19范围的索引项，然后根据索引项内的文件偏移到segment上读取raft log。大概的流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-9ba37bc712105e45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-2-写数据流程&#34;&gt;3.2 写数据流程&lt;/h3&gt;

&lt;p&gt;raft算法要求写入的raft log必须强制落盘后，才能返回成功。通过将log entry批量异步写入segment文件，并调用sync_file_range函数强制刷盘。为了提升写入segment性能，segment文件创建时就预分配了512MB的磁盘空间，这种预分配文件空间的方式有助于提升写性能。将索引信息写入index文件是异步写完后就返回。同步写segment，异步写index的方式降低了raft log写耗时，但又不影响raft算法的正确性。因为raft算法是以segment中的数据作为参考标准的。&lt;/p&gt;

&lt;p&gt;Logstore写入流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-ee40bae97ee50651.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-3-数据恢复流程&#34;&gt;3.3 数据恢复流程&lt;/h3&gt;

&lt;p&gt;Logstore必须要考虑到在VDL系统异常退出时，存储的数据有可能出现不一致。例如在Logstore写数据过程中，机器突然宕机。这时候就有可能只写入了部分数据，在设计Logstore时就必须考虑到如何支持数据恢复操作，保证写入Logstore的数据的一致性。&lt;/p&gt;

&lt;p&gt;在Logstore中，只有最后一个segment文件可能出现数据不一致的可能。因为Logstore在写满一个segment文件后，会创建一个新的segment文件。在创建新的segment文件之前，Logstore通过sync系统调用让最后的segment对应的index文件内容强制刷盘，并且最后一个segment文件写入本身就是同步写。通过这种机制保证了只有最后一个segment写入的数据存在部分写的可能。而在这之前的segment文件和index文件内容都是完整的。&lt;/p&gt;

&lt;p&gt;有了上面的保证，数据恢复我们只需要考虑最后一个segment及其index文件中的数据是否完整。Logstore通过一个标识文件来标识系统是否正常退出，如果文件存在且里面的标记为正常退出，Logstore就走正常启动流程，否则，转入数据恢复流程，Logstore数据恢复流程，主要操作如下图所示：
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/66307-1cd3af3df6dd9424.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-logstore的测试&#34;&gt;4.Logstore的测试&lt;/h2&gt;

&lt;p&gt;为保证Logstore的正确性，我们对Logstore对外提供的接口函数及内部调用的核心函数都做了单元测试，通过gitlab+jenkins持续集成的方式，保证每次提交都会触发脚本将所有的单元测试重新运行一次，如果新增代码或改动代码，导致单元测试失败，我们可以立刻发现。通过这种持续集成的方式，我们可以保证每次代码提交的质量。&lt;/p&gt;

&lt;p&gt;仅仅有单元测试还是不够的，因为我们无法预测Logstore某个接口函数异常，对整个VDL系统造成什么影响。所以，我们还对Logstore进行了异常测试，通过一个自研工具FIU，对Logstore中特定的函数注入各种异常条件，测试Logstore的在异常情况下，对系统的影响。我们在Logstore相关代码中插入固定的异常代码，然后通过FIU来触发相应的异常点。这样就可以让Logstore走入指定的异常逻辑代码。异常注入测试主要分为两类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;增加读或写延迟，Logstore向上层提供读写raft log和user log等操作。例如，读取raft log增加3s的延迟、写入user log增加1s-3s的随机延迟。我们测试在这类异常场景下，对上层VDL会造成什么影响，结果是否跟我们的预期一致。&lt;/li&gt;
&lt;li&gt;部分写问题，机器突然宕机，有可能导致Logstore部分写操作。也就是segment有可能只写入了部分数据，或者index文件只写入了部分数据。同样，我们也是在写入segment文件逻辑和index文件逻辑中增加异常点，利用FIU触发指定的异常逻辑。这样就可以测试到在Logstore出现部分写时，Logstore的数据恢复流程是否能够正常工作，是否符合预期。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了这类异常测试，我们可以提前去模拟线上有可能出现的异常场景，并修复可能存在的未知缺陷。保证VDL上线后更加稳定、可靠。并且添加异常各类异常测试用例是一个持续的过程，伴随着VDL系统开发和演进的全过程。&lt;/p&gt;

&lt;h2 id=&#34;5-logstore的性能优化&#34;&gt;5.Logstore的性能优化&lt;/h2&gt;

&lt;p&gt;为保证Logstore具有高性能的读写，在设计阶段就考虑到了。比如通过文件空间预分配来提升写性能，通过mmap方式读日志数据，提升读性能。在代码开发完成后，结合go pprof和火焰图来定位Logstore的性能开销较大的系统调用或代码段，并做相应优化。性能优化方面的工作，比较有意义的几点，可以分享一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;批量写数据，不管是写segment还是写index文件，都是将数据先组合在一个内存空间中，然后批量写入到磁盘。减少IO调用带来的开销。&lt;/li&gt;
&lt;li&gt;index文件异步刷盘，在前面的设计中，我们谈到在segment rolling操作中，需要将index文件同步刷盘后，再创建新的segment文件。通过持续观察发现，每次index文件刷盘都要消耗4ms-8ms的时间。写入操作如果需要segment rolling时，这次的写入延迟额外会增加4ms-8ms。Logstore的写入就会出现抖动。经过分析，我们可以发现index文件同步刷盘所做的操作就是将index文件对应的内存脏页更新到磁盘。如果我们能够减少segment rolling操作时index文件对应的内存脏页数量。就可以缩短index刷盘的耗时。我们采用的方式是每次写index文件时，再调用sync_file_range操作异步将index文件数据刷盘，这样就可以分摊最后一次刷盘的压力。经过优化后的index文件刷盘操作耗时缩短到200us-300us。使得整个Lostore的写入耗时更加平滑。
在核心函数调用中Logstore记录相关metric信息，在Logstore上线后，通过日志收集系统，收集metric信息到influxdb，然后通过grafana展示出来。有了grafana的直观展示，我们可以监控到耗时比较长的系统调用，并做针对性地优化。目前关键的读取和写入操作都达到了预期的性能目标。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-总结&#34;&gt;6.总结&lt;/h2&gt;

&lt;p&gt;本文介绍了Logstore在设计、开发、测试和性能优化等方面，我们所做的工作。希望能够给读者在设计和开发分布式存储系统时，提供一定的参考思路。在后续演进中，我们希望结合业务场景，对数据做冷热分离，进一步降低生产系统的成本。到时候有新的心得体会，我们继续给大家分享。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Raft的PreVote实现机制</title>
      <link>https://flike.github.io/post/1/</link>
      <pubDate>Sun, 07 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://flike.github.io/post/1/</guid>
      
        <description>

&lt;h2 id=&#34;1-背景&#34;&gt;&lt;strong&gt;1. 背景&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在Basic Raft算法中，当一个Follower与其他节点网络隔离，如下图所示：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/66307-64cbd82b30ffb525.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Follower_2在electionTimeout没收到心跳之后,会发起选举，并转为Candidate。每次发起选举时，会把Term加一。由于网络隔离，它既不会被选成Leader，也不会收到Leader的消息，而是会一直不断地发起选举。Term会不断增大。&lt;/p&gt;

&lt;p&gt;一段时间之后，这个节点的Term会非常大。在网络恢复之后，这个节点会把它的Term传播到集群的其他节点，导致其他节点更新自己的term，变为Follower。然后触发重新选主，但这个旧的Follower_2节点由于其日志不是最新，并不会成为Leader。整个集群被这个网络隔离过的旧节点扰乱，显然需要避免的。&lt;/p&gt;

&lt;h2 id=&#34;2-provote算法&#34;&gt;&lt;strong&gt;2. Provote算法&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Raft作者博士论文《CONSENSUS: BRIDGING THEORY AND PRACTICE》的第9.6节 &amp;ldquo;Preventing disruptions when a server rejoins the cluster&amp;rdquo;提到了PreVote算法的大概实现思路。&lt;/p&gt;

&lt;p&gt;在PreVote算法中，Candidate首先要确认自己能赢得集群中大多数节点的投票，这样才会把自己的term增加，然后发起真正的投票。其他投票节点同意发起选举的条件是（同时满足下面两个条件）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有收到有效领导的心跳，至少有一次选举超时。&lt;/li&gt;
&lt;li&gt;Candidate的日志足够新（Term更大，或者Term相同raft index更大）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PreVote算法解决了网络分区节点在重新加入时，会中断集群的问题。在PreVote算法中，网络分区节点由于无法获得大部分节点的许可，因此无法增加其Term。然后当它重新加入集群时，它仍然无法递增其Term，因为其他服务器将一直收到来自Leader节点的定期心跳信息。一旦该服务器从领导者接收到心跳，它将返回到Follower状态，Term和Leader一致。&lt;/p&gt;

&lt;h2 id=&#34;3-etcd的provote实现流程&#34;&gt;&lt;strong&gt;3. Etcd的Provote实现流程&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Etcd针对发起PreVote的节点增加了一个角色状态：StatePreCandidate。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;const (
    StateFollower StateType = iota
    StateCandidate
    StateLeader
    StatePreCandidate
    numStates
)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;3-1-节点发起prevote流程&#34;&gt;&lt;strong&gt;3.1 节点发起PreVote流程&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;1.首先节点超时，会进入Step函数，然后触发选举流程，如果配置了prevote，则会进入预选举流程，代码片段如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;case pb.MsgHup:
        if r.state != StateLeader {
            ents, err := r.raftLog.slice(r.raftLog.applied+1, r.raftLog.committed+1, noLimit)
            if err != nil {
                r.logger.Panicf(&amp;#34;unexpected error getting unapplied entries (%v)&amp;#34;, err)
            }
            if n := numOfPendingConf(ents); n != 0 &amp;amp;&amp;amp; r.raftLog.committed &amp;gt; r.raftLog.applied {
                r.logger.Warningf(&amp;#34;%x cannot campaign at term %d since there are still %d pending configuration changes to apply&amp;#34;, r.id, r.Term, n)
                return nil
            }

            r.logger.Infof(&amp;#34;%x is starting a new election at term %d&amp;#34;, r.id, r.Term)
            if r.preVote {
                r.campaign(campaignPreElection)
            } else {
                r.campaign(campaignElection)
            }
        } else {
            r.logger.Debugf(&amp;#34;%x ignoring MsgHup because already leader&amp;#34;, r.id)
        }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.节点调用r.campaign(campaignPreElection)，发送投票请求。函数流程如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func (r *raft) campaign(t CampaignType) {
    var term uint64
    var voteMsg pb.MessageType
    if t == campaignPreElection {
        r.becomePreCandidate()
        voteMsg = pb.MsgPreVote
        // PreVote RPCs are sent for the next term before we&amp;#39;ve incremented r.Term.
        //关键点：这里raft的term不会增加，先以r.Term + 1询问其他节点，而不增加自己的真实term
        term = r.Term + 1
    } else {
        r.becomeCandidate()
        voteMsg = pb.MsgVote
        term = r.Term
    }
    //检查投票是否过半，第一次进入该函数不会执行这段逻辑。
    //流程3，会统计投票结果
    if r.quorum() == r.poll(r.id, voteRespMsgType(voteMsg), true) {
        // We won the election after voting for ourselves (which must mean that
        // this is a single-node cluster). Advance to the next state.
        if t == campaignPreElection {
            r.campaign(campaignElection)
        } else {
            r.becomeLeader()
        }
        return
    }
    //向其他节点发送投票请求
    for id := range r.prs {
        if id == r.id {
            continue
        }
        r.logger.Infof(&amp;#34;%x [logterm: %d, index: %d] sent %s request to %x at term %d&amp;#34;,
            r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), voteMsg, id, r.Term)

        var ctx []byte
        if t == campaignTransfer {
            ctx = []byte(t)
        }
        r.send(pb.Message{Term: term, To: id, Type: voteMsg, Index: r.raftLog.lastIndex(), LogTerm: r.raftLog.lastTerm(), Context: ctx})
    }
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3.当发起prevote节点收到响应消息以后，会进入stepCandidate函数，stepCandidate函数是PreCandidate状态和Candidate状态共用的。当收到其他节点对投票的响应时，重新计算自己的票数。如果达到大多数，PreCandidate会变为Candidate状态，发起真正的选举。代码片段如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func stepCandidate(r *raft, m pb.Message) error {
    // Only handle vote responses corresponding to our candidacy (while in
    // StateCandidate, we may get stale MsgPreVoteResp messages in this term from
    // our pre-candidate state).
    var myVoteRespType pb.MessageType
    if r.state == StatePreCandidate {
        myVoteRespType = pb.MsgPreVoteResp
    } else {
        myVoteRespType = pb.MsgVoteResp
    }
    switch m.Type {
    ...
    case myVoteRespType:
      //统计赞成票和反对票
        gr := r.poll(m.From, m.Type, !m.Reject)
        r.logger.Infof(&amp;#34;%x [quorum:%d] has received %d %s votes and %d vote rejections&amp;#34;, r.id, r.quorum(), gr, m.Type, len(r.votes)-gr)
        switch r.quorum() {
        case gr:
          //当赞成票过半后，PreVote直接转入第二个阶段：正式选举
            if r.state == StatePreCandidate {
                r.campaign(campaignElection)
            } else {
              //如果已经是StateCandidate,则直接变为Leader，选举结束。
                r.becomeLeader()
                r.bcastAppend()
            }
        case len(r.votes) - gr:
            // pb.MsgPreVoteResp contains future term of pre-candidate
            // m.Term &amp;gt; r.Term; reuse r.Term
            //如果反对票已过半，这直接变为Follower，并且不增加term
            r.becomeFollower(r.Term, None)
        }
    ...
    }
    return nil
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;3-2-节点响应prevote流程&#34;&gt;&lt;strong&gt;3.2 节点响应PreVote流程&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;节点收到Prevote请求，都会进入Step函数，然后做相应的响应处理：
1.如果当前节点未选举超时，并且存在Leader，则不响应投票请求
2.如果满足投票要求，并且日志最新，则投赞成票，否则投反对票。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func (r *raft) Step(m pb.Message) error {
    // Handle the message term, which may result in our stepping down to a follower.
    switch {
    ...
    //#1
    case m.Term &amp;gt; r.Term:
        if m.Type == pb.MsgVote || m.Type == pb.MsgPreVote {
            force := bytes.Equal(m.Context, []byte(campaignTransfer))
            inLease := r.checkQuorum &amp;amp;&amp;amp; r.lead != None &amp;amp;&amp;amp; r.electionElapsed &amp;lt; r.electionTimeout
            if !force &amp;amp;&amp;amp; inLease {
                // If a server receives a RequestVote request within the minimum election timeout
                // of hearing from a current leader, it does not update its term or grant its vote
                r.logger.Infof(&amp;#34;%x [logterm: %d, index: %d, vote: %x] ignored %s from %x [logterm: %d, index: %d] at term %d: lease is not expired (remaining ticks: %d)&amp;#34;,
                    r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term, r.electionTimeout-r.electionElapsed)
                return nil
            }
        }
    ...
    case pb.MsgVote, pb.MsgPreVote:
    ...
    //#2
        // We can vote if this is a repeat of a vote we&amp;#39;ve already cast...
        canVote := r.Vote == m.From ||
            // ...we haven&amp;#39;t voted and we don&amp;#39;t think there&amp;#39;s a leader yet in this term...
            (r.Vote == None &amp;amp;&amp;amp; r.lead == None) ||
            // ...or this is a PreVote for a future term...
            (m.Type == pb.MsgPreVote &amp;amp;&amp;amp; m.Term &amp;gt; r.Term)
        // ...and we believe the candidate is up to date.
        if canVote &amp;amp;&amp;amp; r.raftLog.isUpToDate(m.Index, m.LogTerm) {
            ...
            r.send(pb.Message{To: m.From, Term: m.Term, Type: voteRespMsgType(m.Type)})
            if m.Type == pb.MsgVote {
                // Only record real votes.
                r.electionElapsed = 0
                r.Vote = m.From
            } else {
            ...
            r.send(pb.Message{To: m.From, Term: r.Term, Type: voteRespMsgType(m.Type), Reject: true})
        }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;4-总结&#34;&gt;&lt;strong&gt;4. 总结&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Prevote是一个典型的2PC协议，第一阶段先征求其他节点是否同意选举，如果同意选举则发起真正的选举操作，否则降为Follower角色。这样就避免了网络分区节点重新加入集群，触发不必要的选举操作。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>